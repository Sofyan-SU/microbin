{% include "header.html" %}
<div id="decryption-button-container">
  <button id="copy-button" class="small-button" style="margin-right: 0.5rem" onclick="copyToClipboard(content, this, 'Copy Text')">
    Copy Text
  </button>

  {% if args.public_path_as_str() != "" && pasta.pasta_type == "url" %}
  <button id="copy-redirect-button" class="small-button" style="margin-right:
  0.5rem">
    Copy Redirect
  </button>
  {%- endif %}
  <a style="margin-right: 1rem" href="{{ args.public_path_as_str()  }}/raw/{{pasta.id_as_animals()}}">Raw Text
    Content</a>
  {% if args.qr && args.public_path_as_str() != "" %}
  <a style="margin-right: 1rem" href="{{ args.public_path_as_str()  }}/qr/{{pasta.id_as_animals()}}">QR</a>
  {%- endif %} {% if pasta.editable && ! pasta.encrypt_client %}
  <a style="margin-right: 1rem" href="{{ args.public_path_as_str()  }}/edit/{{pasta.id_as_animals()}}">Edit</a>
  {%- endif %}
  {% if pasta.editable %}
  <a style="margin-right: 1rem" href="{{ args.public_path_as_str()}}/remove/{{pasta.id_as_animals()}}">Remove</a>
  {%- endif %}
  {% if pasta.encrypt_client && pasta.attachments.is_some() %}
  <button id="download-all-encrypted-button" class="small-button" style="margin-right: 0.5rem; margin-top: 0.5rem">
    Download all (Decrypted Zip)
  </button>
  {%- endif %}
  {% if !pasta.encrypt_client && pasta.attachments.is_some() %}
  <button id="download-all-unencrypted-button" class="small-button" style="margin-right: 0.5rem; margin-top: 0.5rem" onclick="window.location.href='{{ args.public_path_as_str() }}/archive/{{pasta.id_as_animals()}}'">
    Download all as ZIP
  </button>
  {%- endif %}
  {% if pasta.attachments.is_some() %}
  <select id="view-selector" class="small-button" style="margin-right: 0.5rem; margin-top: 0.5rem">
    <option value="gallery">Gallery</option>
    <option value="stream">Stream</option>
    <option value="list">List</option>
  </select>
  {%- endif %}
</div>

<div id="decryption-container" style="margin-bottom: 2rem; display: flex;
justify-content: center; align-items: center;">
  <div id="decryption">
    {% if pasta.encrypt_client %}
    <label for="password-field" style="margin-bottom: 0.5em;">
      Please enter your key to decrypt this upload. <sup> <a href="{{ args.public_path_as_str() }}/guide#encryption">?</a></sup>
    </label>
    <input class="small-button" placeholder="Key" style="margin-right: 0.5rem" type="password" id="password-field"
      autocomplete="off" />
    {% if pasta.content != "" %}
    <button class="small-button" id="decrypt-button" style="margin-right:
    0.5rem">
      <b>
        Decrypt text
      </b>
    </button>
    {%- endif %}
    {%- endif %}
    {% if pasta.file.is_some() && ! pasta.file_embeddable() %}
    <button type="button" class="small-button" id="download-button" style="margin-right:
  0.5rem">
      <b>
        {% if pasta.encrypt_client %}
        Decrypt and download file
        {%- else %}
        Download file
        {%- endif %}
      </b>
    </button>
    {%- endif %}
  </div>
</div>

{% if pasta.content != "" %}
<div class="code-container">
  <div style="clear: both;">
    {% if pasta.extension == "auto" || pasta.encrypt_client %}
    <pre><code id="code">{{pasta.content_escaped()}}</code></pre>
    {% else if args.highlightsyntax %}
    <pre><code id="code">{{pasta.content_syntax_highlighted()}}</code></pre>
    {% else %}
    <pre><code id="code">{{pasta.content_not_highlighted()}}</code></pre>
    {%- endif %}
  </div>
</div>
{%- endif %}

<div id="gallery-view" class="gallery-grid" style="display: grid; margin-top: 2rem;">
    {% if pasta.file.is_some() %}
    <div style="max-width: 100%; overflow: hidden;">
        {% let file = pasta.file.as_ref().unwrap() %}
        {% include "assets/file_card.html" %}
    </div>
    {% endif %}

    {% if pasta.attachments.is_some() %}
        {% for file in pasta.attachments.as_ref().unwrap() %}
            {% include "assets/file_card.html" %}
        {% endfor %}
    {% endif %}
</div>

<div id="list-view" style="display: none; margin-top: 2rem;">
    <table style="width: 100%; border-collapse: collapse;">
        <thead>
            <tr style="text-align: left; border-bottom: 1px solid #ccc;">
                <th style="padding: 8px;">Filename</th>
                <th style="padding: 8px;">Size</th>
                <th style="padding: 8px;">Action</th>
            </tr>
        </thead>
        <tbody>
            {% if pasta.file.is_some() %}
            <tr>
                {% let file = pasta.file.as_ref().unwrap() %}
                <td style="padding: 8px;">{{ file.name() }}</td>
                <td style="padding: 8px;">{{ file.size }}</td>
                <td style="padding: 8px;">
                    <a href="{{ args.public_path_as_str() }}/file/{{pasta.id_as_animals()}}?fname={{ file.name() }}" 
                       class="download-link" 
                       data-filename="{{ file.name() }}">
                        Download
                    </a>
                </td>
            </tr>
            {% endif %}

            {% if pasta.attachments.is_some() %}
            {% for file in pasta.attachments.as_ref().unwrap() %}
            <tr>
                <td style="padding: 8px;">{{ file.name() }}</td>
                <td style="padding: 8px;">{{ file.size }}</td>
                <td style="padding: 8px;">
                    <a href="{{ args.public_path_as_str() }}/file/{{pasta.id_as_animals()}}?fname={{ file.name() }}" 
                       class="download-link" 
                       data-filename="{{ file.name() }}">
                        Download
                    </a>
                </td>
            </tr>
            {% endfor %}
            {% endif %}
        </tbody>
    </table>
</div>

<script type="text/javascript" src="{{ args.public_path_as_str() }}/static/jszip.min.js"></script>
<script>
  const copyBtn = document.getElementById("copy-button")
  const copyRedirectBtn = document.getElementById("copy-redirect-button")
  var content = `{{ pasta.content_escaped() }}`
  const contentElement = document.getElementById("code");
  const url = (`{{ args.short_path_as_str()}}` === "") ? `{{ args.public_path_as_str() }}/upload/{{pasta.id_as_animals()}}` : `{{ args.short_path_as_str()}}/p/{{pasta.id_as_animals()}}`
  const redirect_url = (`{{ args.short_path_as_str()}}` === "") ? `{{ args.public_path_as_str() }}/url/{{pasta.id_as_animals()}}` : `{{ args.short_path_as_str()}}/u/{{pasta.id_as_animals()}}`

  const te = new TextEncoder();

  // {% if pasta.extension == "auto" && ! pasta.encrypt_client %}
  onload = (event) => {
    contentElement.innerHTML = content;
    hljs.highlightAll();
  };
  // {% endif %}


  function copyToClipboard(text, buttonElement, originalLabel) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => {
        showCopiedFeedback(buttonElement, originalLabel);
      }).catch(err => {
        console.error('Failed to copy using Clipboard API: ', err);
        fallbackCopyTextToClipboard(text, buttonElement, originalLabel);
      });
    } else {
      fallbackCopyTextToClipboard(text, buttonElement, originalLabel);
    }
  }

  function fallbackCopyTextToClipboard(text, buttonElement, originalLabel) {
    var textArea = document.createElement("textarea");
    textArea.value = text;
    
    // Ensure it's not visible but part of the DOM
    textArea.style.position = "fixed";
    textArea.style.left = "-9999px";
    textArea.style.top = "0";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      var successful = document.execCommand('copy');
      if (successful) {
        showCopiedFeedback(buttonElement, originalLabel);
      } else {
        console.error('Fallback: Copying text command was unsuccessful');
      }
    } catch (err) {
      console.error('Fallback: Oops, unable to copy', err);
    }

    document.body.removeChild(textArea);
  }

  function showCopiedFeedback(buttonElement, originalLabel) {
    buttonElement.innerHTML = "Copied";
    setTimeout(() => {
      buttonElement.innerHTML = originalLabel;
    }, 1000);
  }

  if (copyRedirectBtn) {
    copyRedirectBtn.onclick = function () {
      copyToClipboard(redirect_url, copyRedirectBtn, "Copy Redirect");
    };
  }

  function escapeHtml(unsafe) {
    if (!unsafe) return "";
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  const decryptDiv = document.getElementById('decryption');
  const decryptButton = document.getElementById('decrypt-button');
  const passwordField = document.getElementById("password-field");
  const downloadButton = document.getElementById('download-button');

  if (decryptButton) {
      decryptButton.addEventListener('click', () => {
        password = passwordField.value;

        content = contentDecrypted = escapeHtml(decryptWithPassword(password, content));
        if (contentDecrypted) {
          contentElement.innerHTML = contentDecrypted;
          // {% if pasta.extension == "auto" %}
          hljs.highlightAll();
          // {%- endif %}
        }
      });
  }

  function decryptWithPassword(password, encryptedHex) {
    const passwordBytes = aesjs.utils.utf8.toBytes(password.padStart(32, "#"));
    const encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);
    const aesCtr = new aesjs.ModeOfOperation.ctr(passwordBytes);
    const decryptedBytes = aesCtr.decrypt(encryptedBytes);
    const res = aesjs.utils.utf8.fromBytes(decryptedBytes);

    if (res.endsWith("!0K")) {
      return res.substring(0, res.length - 3);
    } else {
      alert("Decryption failed. Check password.");
      return "";
    }
  }

  function decryptFileWithPassword(password, encryptedHex) {
    const passwordBytes = aesjs.utils.utf8.toBytes(password.padStart(32, "#"));
    const encryptedBytes = aesjs.utils.hex.toBytes(encryptedHex);
    const aesCtr = new aesjs.ModeOfOperation.ctr(passwordBytes);
    const decryptedBytes = aesCtr.decrypt(encryptedBytes);
    return decryptedBytes;
  }

  // View switch logic
  const view = new URLSearchParams(window.location.search).get('view');
  
  const galleryView = document.getElementById('gallery-view');
  const listView = document.getElementById('list-view');
  const viewSelector = document.getElementById('view-selector');

  if (viewSelector) {
      // Set initial value
      viewSelector.value = view || 'gallery';
      
      // Handle change
      viewSelector.addEventListener('change', (e) => {
          const newView = e.target.value;
          const currentUrl = new URL(window.location.href);
          currentUrl.searchParams.set('view', newView);
          window.history.pushState({}, '', currentUrl); // Update URL without reload

          // Apply view change immediately
          if (galleryView && listView) {
              if (newView === 'list') {
                  galleryView.style.display = 'none';
                  listView.style.display = 'block';
              } else if (newView === 'stream') {
                  galleryView.style.setProperty('display', 'grid', 'important');
                  galleryView.classList.add('stream-view');
                  listView.style.display = 'none';
              } else {
                  galleryView.style.setProperty('display', 'grid', 'important');
                  galleryView.classList.remove('stream-view');
                  listView.style.display = 'none';
              }
          }
      });
  }
  
  // Set initial visibility
  if (galleryView && listView) {
      if (view === 'list') {
          galleryView.style.display = 'none';
          listView.style.display = 'block';
      } else if (view === 'stream') {
          galleryView.style.setProperty('display', 'grid', 'important');
          galleryView.classList.add('stream-view');
          listView.style.display = 'none';
      } else {
          galleryView.style.setProperty('display', 'grid', 'important');
          galleryView.classList.remove('stream-view');
          listView.style.display = 'none';
      }
  }

  // Encrypted Download Logic
  // {% if pasta.encrypt_client %}
  // Attach listeners to all download links for encrypted files
  document.querySelectorAll('.download-link').forEach(link => {
      link.addEventListener('click', async (event) => {
        event.preventDefault();
        
        if (passwordField.value.trim() == "") {
          passwordField.focus();
          return false;
        }

        const filename = link.getAttribute('data-filename');
        const url = link.href;
        
        const response = await fetch(url);
        const encryptedFile = await response.arrayBuffer();
        const encryptedBytes = new Uint8Array(encryptedFile);
        
        // Decrypt
        const hex = Array.from(encryptedBytes).map(b => b.toString(16).padStart(2, "0")).join("");
        const decryptedContents = decryptFileWithPassword(passwordField.value.trim(), hex);
        
        if (!decryptedContents) {
             alert("Decryption failed. Check password.");
             return;
        }

        const decryptedBlob = new Blob([decryptedContents], { type: 'application/octet-stream' });
        const tempAnchorEl = document.createElement('a');
        tempAnchorEl.href = URL.createObjectURL(decryptedBlob);
        tempAnchorEl.download = filename;
        tempAnchorEl.click();
      });
  });

  const downloadAllEncryptedBtn = document.getElementById('download-all-encrypted-button');
  if (downloadAllEncryptedBtn) {
      downloadAllEncryptedBtn.addEventListener('click', async (event) => {
          event.preventDefault();

          if (passwordField.value.trim() == "") {
              passwordField.focus();
              return false;
          }

          downloadAllEncryptedBtn.textContent = "Processing...";
          downloadAllEncryptedBtn.disabled = true;

          try {
              const zip = new JSZip();
              const links = Array.from(document.querySelectorAll('.download-link'));
              // Deduplicate by filename
              const uniqueLinks = new Map();
              links.forEach(link => {
                  const filename = link.getAttribute('data-filename');
                  if (!uniqueLinks.has(filename)) {
                      uniqueLinks.set(filename, link.href);
                  }
              });

              const promises = [];

              for (const [filename, url] of uniqueLinks) {
                  promises.push(new Promise(async (resolve, reject) => {
                      try {
                          const response = await fetch(url);
                          const encryptedFile = await response.arrayBuffer();
                          const encryptedBytes = new Uint8Array(encryptedFile);

                          const hex = Array.from(encryptedBytes).map(b => b.toString(16).padStart(2, "0")).join("");
                          const decryptedContents = decryptFileWithPassword(passwordField.value.trim(), hex);

                          if (decryptedContents) {
                              zip.file(filename, decryptedContents);
                          } else {
                              console.error(`Failed to decrypt ${filename}`);
                          }
                          resolve();
                      } catch (e) {
                          console.error(`Error processing ${filename}`, e);
                          resolve(); // Continue even if one fails
                      }
                  }));
              }

              await Promise.all(promises);

              const content = await zip.generateAsync({type:"blob"});
              const tempAnchorEl = document.createElement('a');
              tempAnchorEl.href = URL.createObjectURL(content);
              tempAnchorEl.download = "{{pasta.id_as_animals()}}.zip";
              tempAnchorEl.click();

              downloadAllEncryptedBtn.textContent = "Download all (Decrypted Zip)";
              downloadAllEncryptedBtn.disabled = false;
          } catch (e) {
              console.error("Zip generation failed", e);
              alert("Failed to generate zip. See console.");
              downloadAllEncryptedBtn.textContent = "Download all (Decrypted Zip)";
              downloadAllEncryptedBtn.disabled = false;
          }
      });
  }

  const singleDownloadBtn = document.getElementById('download-button');
  if (singleDownloadBtn) {
      singleDownloadBtn.addEventListener('click', async (event) => {
        event.preventDefault();
        
        if (passwordField.value.trim() == "") {
          passwordField.focus();
          return false;
        }

        const originalText = singleDownloadBtn.innerHTML;
        singleDownloadBtn.textContent = "Decrypting...";
        singleDownloadBtn.disabled = true;

        try {
             const url = `{{ args.public_path_as_str()  }}/raw/{{pasta.id_as_animals()}}`;
             let filename = `{{ pasta.id_as_animals() }}`;
             // Try to guess extension from content type if possible, or just use .enc
             if (filename.endsWith(".enc")) {
                 filename = filename.substring(0, filename.length - 4);
             }

            // Fetch encrypted file from server using POST and password
            const formData = new FormData();
            
            let passwordToSend = passwordField.value.trim();
            // {% if pasta.encrypted_key.is_some() %}
            try {
                 passwordToSend = decryptWithPassword(passwordField.value.trim(), "{{ pasta.encrypted_key.as_ref().unwrap() }}");
            } catch (e) {
                 console.error("Failed to decrypt key", e);
            }
            // {%- endif %}
            
            formData.append('password', passwordToSend);

            const response = await fetch(url, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Server returned ${response.status} ${response.statusText}`);
            }
            
            let hex = await response.text();
            
            if (hex.trim().startsWith("<")) {
                const preview = hex.trim().substring(0, 100);
                console.error("Server returned HTML:", preview);
                throw new Error("Server returned HTML (likely error page): " + preview);
            }

            hex = hex.trim(); 
            
            if (hex.length === 0) {
                 throw new Error("Decryption failed: File is empty.");
            }
            
            const decryptedContents = decryptFileWithPassword(passwordField.value.trim(), hex);
            
            if (!decryptedContents) {
                 alert("Decryption failed. Check password.");
                 singleDownloadBtn.innerHTML = originalText;
                 singleDownloadBtn.disabled = false;
                 return;
            }

            const decryptedBlob = new Blob([decryptedContents], { type: 'application/octet-stream' });
            const tempAnchorEl = document.createElement('a');
            tempAnchorEl.href = URL.createObjectURL(decryptedBlob);
            tempAnchorEl.download = filename;
            tempAnchorEl.click();
            
            singleDownloadBtn.innerHTML = originalText;
            singleDownloadBtn.disabled = false;

        } catch (e) {
            console.error("Download failed", e);
            alert("Download error: " + e.message);
            singleDownloadBtn.innerHTML = originalText;
            singleDownloadBtn.disabled = false;
        }
      });
  }
  // {%- endif %}
</script>

<style>
  .code-container {
    clear: left;
  }

  code-line::before {
    content: counter(line);
    display: inline-block;
    padding-left: auto;
    margin-left: auto;
    text-align: left;
    width: 1.8rem;
    border-right: 1px solid lightgrey;
    color: grey;
    margin-right: 0.4rem;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  code-line {
    display: block;
    counter-increment: line;
  }

  #embed {
    background-color: #f7f7f7;
    border-radius: 6px;
    margin-top: 1rem;
    margin-bottom: 1rem;
    width: fit-content;
    padding: 10px;
    padding-left: 1.2rem;
    padding-right: 1.2rem;
  }

  #decryption-button-container {
    margin-bottom: 1rem;
    display: block;
  }

  .small-button {
    padding: 4px;
    padding-left: 0.8rem;
    padding-right: 0.8rem;
    cursor: pointer;
  }

  .code-container {
    background-color: #f7f7f7;
    border-radius: 6px;
    padding: 1rem;
    font-size: 0.9rem;
    overflow-x: auto;
  }

  .file-button {
    padding: 4px;
    padding-left: 0.8rem;
    padding-right: 0.8rem;
    cursor: pointer;
  }

  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1rem;
  }

  .file-card {
    background-color: var(--background-body); 
    /* border removed as requested */
    border-radius: 8px;
    padding: 0.5rem;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .embed-media {
    width: 100%;
    border-radius: 4px;
    cursor: pointer;
    transition: transform 0.2s;
  }

  .gallery-grid .embed-media {
    aspect-ratio: 1 / 1;
    object-fit: cover;
  }

  .stream-view {
    display: flex !important;
    flex-direction: column !important;
    gap: 2rem !important;
  }

  .stream-view .file-card {
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
  }

  .stream-view .embed-media {
    aspect-ratio: auto;
    object-fit: contain;
    max-height: 80vh;
  }

  /* Adjust video to containment if controls are needed, but user asked for cropped previews. 
     If controls are hidden by cropping, it's a trade-off. 
     Let's keep cover for uniformity as requested. */
</style>

{% if ! args.pure_html %}
<style>
  #decryption {
    background-color: #f7f7f7;
    border-radius: 6px;
    padding: 10px;
    width: fit-content;
  }
</style>
{%- endif %}

{% include "footer.html" %}